\chapter{Optimization algorithm}

This section is still under active development and is quite incomplete both theoretically and computationally due to the time limit that has been unexpectedly imposed. Somehow, the god of AI has our back. So, enjoy the chapter!

\section{Overview}

Originally, we planned to use the stochastic gradient descent algorithm straight on the possible air conditioner position. However, it falls short because most of the best points are all scattered throughout the rooms. The time until equilibrium of most half-way point of a straight wall is mostly similar, and is the optimal position. Meaning that there are many hills and valleys in our loss function; thus, gradient descent is basically out of the window.

It was depressing. It took us four weeks before realizing that both the original gradient descent and its best cousin, \texttt{Adam}, literally doesn't work because the room's geometry. When there's a long straight wall, the function is smooth, and the local minima usually sits at the center of the straight wall. At the end of these walls are usually sharp corners, and these corners creates a spike in the function, so gradient descent wouldn't work. We hypothesized that a better algorithm would probably be a detection of all straight walls, find the midpoint of each one, then compare. However, we're already reaching the time limit of AI Builders. So that is out of the window as well. % This part must be rewritten

Recognizing that the visual geometry of the room is significant to optimizing the air conditioner placement, we settled for a convolutional neural network: a machine-learning method which can easily recognize the shape of a room. The overview of the plan is as follows:
\begin{enumerate}[noitemsep]
    \item Generate a data set that captures
          \begin{enumerate}[noitemsep]
              \item \textbf{Data}---The shape of the room in as \texttt{.png} files
              \item \textbf{Labels}---The best air conditioner position as a tuple $(Y, X)$
          \end{enumerate}
    \item Import the data into a \texttt{tensorflow} compatible format, then do train-test split
    \item Design the convolutional neural networks layer
    \item Train the model using the square of the mean squared error loss function
\end{enumerate}

\paragraph{Generation of best position} The best position is determined via brute-forcing through every possible positions that has been indexed by the \texttt{indexPosibleACPos} function and measuring the fastest time until equilibrium. The point that makes the room reaches an equilibrium the fastest is said to be \enquote{the best position.} However, this method has its own pitfalls. In that, the air conditioner is supposed to distribute the air evenly, so a more proper indexing must be
\begin{quote}
    \emph{The best air conditioner position that makes the difference of velocity of air along the boundaries the least.}
\end{quote}
However, the algorithm to determine this is too complex to be done in the time limit imposed. It will be changed to a correct one after the \texttt{AI Builders X ESCK} is done.

\paragraph{Generation of best air conditioner position} The \emph{best air conditioner placement in a room} is generated by brute-forcing through all the possible positions of air conditioner that's indexed by the function \texttt{indexPossibleACPos}.

\paragraph{Reasons for the mean-squared loss function} Since we want to predict the optimal position of the air conditioner in a room, we want the AI to minimize the distance between the prediction and the actual position. This feature is captured by the Pythagorean distance:
\begin{equation}
    d = \sqrt{(y - y')^2 + (x - x')^2}
\end{equation}
where $(y, x)$ is the actual value and $(y', x')$ is the predicted value. If we take the Pythagorean distance and square it, then throw in many data points and calculate the error between them, what we get is exactly the mean squared error.
\begin{equation}
    \bar{d^2} = \frac{1}{n}\sum_{i = 1}^{n}\ab((y_i - y'_i)^2 + (x_i - x_i')^2),
\end{equation}
where $n$ is the amount of data points that's used to validate the AI. Since the system that we are dealing with is continuous, and there are no classifications involved, the loss function directly reflects the accuracy of the model, and can be used as a metric for the model as well.

\section{Data generation algorithm}

The room generator works on a set of predetermined coordinates determined based on room size. A random amount of obstacles (Obstacles here are defined as areas that are inaccessible, whether that be furniture, columns, or wall curvature) are then placed randomly onto these positions with position harboring more than one obstacle. All the possible positions are stored in the \texttt{WallBoundary} class, and is initialized as follows:
\begin{minted}{python}
self.possiblePositions = [
    (int(self.yResolution / 3), self.xResolution - 1),
    (int(2 * self.yResolution / 3), self.xResolution - 1),
    (0, int(self.xResolution / 3)),
    (0, int(2 * self.xResolution / 3)),
    (int(self.yResolution / 3), 0),
    (int(2 * self.yResolution / 3), 0),
    (self.yResolution - 1, int(self.xResolution / 3)),
    (self.yResolution - 1, int(2 * self.xResolution / 3)),
    (0, self.xResolution - 1),
    (0, 0),
    (self.yResolution - 1, 0),
    (self.yResolution - 1, self.xResolution - 1),
]
\end{minted}

There are two types of obstacles: rectangular ones and cylindrical ones. The type of obstacle placed is determined by a random float generator, picking circles and rectangles on a ratio of 4:6 respectively.

Then, we define a function \texttt{generateRoom} in the class \texttt{WallBoundary} as follows:
\begin{minted}{python}
def generateRoom(self):
    for i in random.sample(range(12), k=random.randint(1, 12)):
        wallPos = self.possiblePositions[i]
        if random.random() < 0.4:
            if random.random() < 0.1:
                maxSize = int(min(self.yResolution, self.xResolution) * 0.7)
                minSize = int(min(self.yResolution, self.xResolution) * 0.5)
            else:
                maxSize = int(min(self.yResolution, self.xResolution) * 0.3)
                minSize = int(min(self.yResolution, self.xResolution) * 0.2)
            sizeR = random.randint(minSize, maxSize)
            self.cylindricalWall(wallPos, sizeR)
        else:
            if random.random() < 0.2:
                maxSize = int(min(self.yResolution, self.xResolution) * 0.6)
                minSize = int(min(self.yResolution, self.xResolution) * 0.3)
            else:
                maxSize = int(min(self.yResolution, self.xResolution) * 0.4)
                minSize = int(min(self.yResolution, self.xResolution) * 0.2)
            
            sizeX = random.randint(minSize, maxSize)
            sizeY = random.randint(minSize, maxSize)
            rectPos = (
                wallPos[0] - ((sizeY * WallBoundary.directions[i][0])/2),
                wallPos[1] - ((sizeX * WallBoundary.directions[i][1])/2),
            )
            endPos = (
                wallPos[0] + ((sizeY * WallBoundary.directions[i][0])/2),
                wallPos[1] + ((sizeX * WallBoundary.directions[i][1])/2),
            )
            self.filledStraightRectangularWall(rectPos, endPos)
\end{minted}

The cylindrical wall is added to the room contours using a function that takes in the center-point, and the radius. The size of the circle is picked in two steps. First, we see if we'll get a big circle or a small circle, at a chance of $40\%$ and $60\%$ respectively. This is due to the fact that, during testing, it was found that too many large circles often created small 1-pixel channels with little to no airflow. Increasing the size range of all circles didn't work, since those channels would still appear, and we would also have to increase the size of the rectangular walls to prevent creating pockets with no air-flow at all. Thus, it was decided that if a circle was going to be big, it was going to be very big, but also very rare, making it take up as much space as possible to prevent space between it and other obstacles.

The rectangular ones operate on the same principles as the cylindrical ones, only with probabilities tweaked for the average size to be smaller, as larger and longer rectangles protruding from the walls would further increase the chance of air pockets. The generator function for this takes in the top-left, and bottom-right position of the rectangles, and thus additional math is needed to convert center, height, and length into that format.

The generators are then written as a dataframe as follows:
\begin{minted}{python}
 new = pd.DataFrame(
    {
        "BestX" : [],
        "BestY" : [],
        "BestTime" : [],
        "WorstTime" : [],
        "ImageLink": [],
        "SizeX": [],
        "SizeY": [],
        "NumberOfCuts": [],
        "TypesOfCuts": [],
        "CutPositionsX": [],
        "CutPositionsY": [],
        "CutSizesX":  [],
        "CutSizesY": []
    }
)
for i in range(1000000):
    yResolution = 32
    xResolution = 32
	# Room size is fixed to 32x32
    ACspeed = 1

    walls = WallBoundary(yResolution, xResolution)
    walls.borderWall()
    conditions = walls.generateRoom()
    walls.generateIndex()
    walls.generateACDirections()
    walls.indexWithoutCare()   
\end{minted}

Then, another function is used to generate the room based on the previous function, and index all the possible positions the air conditioner can go on.
\begin{minted}{python}
for index, pos in enumerate(walls.possibleACIndex):
    print(f"Simulation batch {start}/{total}")
    simTimes = []
    for directionIndex, direction in enumerate(WallBoundary.unitVect):
        #print(f"Trying direction: {direction}...")
        pathOfFlow = [i+j for i, j in zip(pos, direction)]
        if (not walls.boundary[pathOfFlow[0], pathOfFlow[1]]):
            #print("Works! Testing now...")
            velocityInlet = [VelocityBoundary(pos[0], pos[1], ACspeed, directionIndex)]
            initCondition = np.ones((yResolution, xResolution, Simulation.latticeSize)) / 9
            simulation = Simulation(
                yResolution, xResolution, initCondition, walls, velocityBoundaries=velocityInlet, pressureBoundaries=[]
            )
            simTime, stable = simulation.simulateUntilEquilibrium(
                equilibriumThreshold=2.5, limit=500
            )
            #print("Done!")
            if not stable or simTime == 500:
                #print("It exploded :() or didn't equalize")
                break
            simTimes.append(simTime)
        #else:
            #print("Doesn't work! Moving on...")
        #print("\n")
    results.append(np.average(simTimes))
    start += 1
    #print("--------------")}
\end{minted}

Then, the generator iterate through all positions and viable (facing into open air) directions. For position, its result is saved as the average result from all viable directions.
\begin{minted}{python}
    if(len(results) == 0):
        continue

    full_frame()
    plt.imshow(walls.invertedBoundary, cmap="hot", interpolation="nearest")
    imgpath = f'data/images/{count}.png'
    plt.savefig(imgpath, bbox_inches="tight", pad_inches=0)
    # Save image of room.
   
    results = np.nan_to_num(results, copy=False, nan=501)
    # In case some positions averages equate to nan, covert to 501.
    lowest = min(results)
    most = max(results)
    ansIndex = [index for index, result in enumerate(results) if result == lowest][0]
    # Get the index with the lowest result.
    ansPos = walls.possibleACIndex[ansIndex]

    conditions["BestX"] = [ansPos[1]]
    conditions["BestY"] = [ansPos[0]]
    conditions["BestTime"] = [lowest]
    conditions["WorstTime"] = [most]
    conditions["ImageLink"] = [imgpath]

    print(f"position: {ansPos} Momentum: {results[ansIndex]}")
    df_dictionary = pd.DataFrame(conditions)
    new = pd.concat([new, df_dictionary], ignore_index=True)
    count += 1
    # Save everything to data.
\end{minted}

\section{Convolutional neural network}

We used \texttt{Tensorflow}'s Convolutional Neural Network framework to train our model. The images of the room were scaled down from their original $480\times 480$ size to a more manageable $32\times 32$ size. Its grayscale values were also inverted for more efficiency. We had generated $1438$ possible room layouts and air conditioner positions, and used it to train and test our model with a train to test ratio of $7:3$. Our model has ten layers, consisting of \texttt{Conv2D}, \texttt{MaxPooling2D}, and Dense layers arranged as follows:
\begin{enumerate}
    \item \texttt{Conv2D(32, (4, 4), activation="relu", input\_shape=(32, 32, 1))}
    \item \texttt{MaxPooling2D((2, 2))}
    \item \texttt{Conv2D(64, (4, 4), activation="relu")}
    \item \texttt{MaxPooling2D((2, 2))}
    \item \texttt{Conv2D(64, (4, 4), activation="relu")}
    \item \texttt{Flatten()}
    \item \texttt{Dense(64, activation="relu")}
    \item \texttt{Dense(32, activation="relu")}
    \item \texttt{Dense(16, activation="relu")}
    \item \texttt{Dense(2, activation="relu")}
\end{enumerate}
The first five is used to extract features that are relevant to our system, and the last five is used to calculate those features and output it into numbers while keeping computational overhead low. In the end, we used the \texttt{Adam} optimizer to increase the training efficiency, and the best error (using MSE) we could achieve was $2.56$, meaning that the predicted position was on average $1.5$ pixels away from the optimal position. 

Our baseline was roughly calculated based on the assumption that since most rooms are rectangular, ours being a square of size $32\times 32$ in particular, the minimal distance from the optimal position where cooling starts to be affected should be about $1$ side or $32$ pixels, since from optimal testing it appears the optimal placement tended towards corners. This means that the highest acceptable error is around $45$, since maximum distance where cooling time would be minimally affected. Thus, comparing this to our actual error of $2.56$, our AI is a success.

\section{Discussion}

{\small \emph{Written by Puripat Thumbanthu as strongly advised by Assoc. Prof. Dr. Wiwat Ruenglertpanyakul}}

Here, I'd like to address the pitfalls of the model. By my standards, this project is more than complete. We have built a full-fledged two-dimensional fluid simulation in less than ten weeks. From knowing literally nothing about the field to being able to understand the equation that underlies it. It is a huge achievement in terms of learning. The convolutional neural networks also worked extremely well for the room shapes in two dimensions. Too well almost. However, this project has many major pitfalls that I feel too guilty to not state it before ending this report. So, I shall address the elephant in the room here.

Firstly, the fluid simulation currently applies only partially to three-dimensional systems. Most of the airflow in a room is driven by secondary and tertiary flows, which are responsible for creating vortices. While secondary flows occur in two dimensions, tertiary flows do not. These tertiary flows contribute significantly to the complexity of simulating fluids in three dimensions. Addressing this issue would require extending the Lattice-Boltzmann method to three dimensions—a feasible task, but one that would significantly delay data processing.

Secondly, the boundary conditions in the Lattice-Boltzmann method do not fully capture air conditioner dynamics. An actual air conditioner functions as both a velocity and a pressure boundary condition. The reason a room doesn't explode under the influence of the air conditioner is that walls and windows allow air to escape. Those walls and leaks aren't included in our model yet. Instead, we rely on the assumption that a density boundary condition can approximate the effects of velocity and pressure boundary conditions, which introduces some inaccuracies. These inaccuracies are also doubled down by the fact that the function that we used are the time until fluid equilibrium, not thermal differences on the wall.

Thirdly, there isn't a standard metric that can capture the exact thermal units of an air conditioner in the Lattice-Boltzmann method. From my current knowledge, the Lattice-Boltzmann method is quite a mathematical method, and there isn't a well-defined unit for measurement. The room that we used is $32\times 32$, but the size of the density boundary condition is only $1\times 1$. We don't know the exact magnitude of the fluid vector that can imitate a home air conditioner with $12,000$ BTU. If a $1\times 1$ density boundary actually represents a square meter of air conditioning unit, let's say $12,000$ BTU, that would be like trying to cool down a closed basketball field with a single air conditioner, which is absurd. Still, we don't know if this is true or not.

Nonetheless, despite the limitations of our computational model as well as certain time constraints imposed on us, I have achieved the goal I set out to achieve during my time in this camp, and still attest to the level of quality that our model has. This would not be possible if not for P. Jenta Wonglertsakul and P. Nattavee Sunitsakul, our mentor that has guided us all the way through, and our colleague, Kritpatchara Wongkwan, for providing us with this opportunity to learn much about fluid dynamics and artificial intelligence by contacting \texttt{AI Builders} team to host this \texttt{AI Builders X ESCK} event in the first place.